<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bootstrap-splitter.js - BootStrap-DevExpress API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="BootStrap-DevExpress API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.001(alpha)</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Modal.html">Modal</a></li>
            
                <li><a href="../classes/NavBar.html">NavBar</a></li>
            
                <li><a href="../classes/Splitter.html">Splitter</a></li>
            
                <li><a href="../classes/Tab.html">Tab</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Modal.html">Modal</a></li>
            
                <li><a href="../modules/NavBar.html">NavBar</a></li>
            
                <li><a href="../modules/Splitter.html">Splitter</a></li>
            
                <li><a href="../modules/Tab.html">Tab</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: bootstrap-splitter.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * js插件:区域分割
 * @module Splitter
 */

!(function($) {

	&quot;use strict&quot;; // jshint ;_;
	/**
	 * 分割区域发生改变时触发
	 * @event onresize
	 * @param {Object} ev  回调参数
	 * @param {Object} ev.A  区域A对象
	 * @param {Number} ev.A.height 区域A的高度
	 * @param {Number} ev.A.width 区域A的宽度
	 * @param {Object} ev.B 区域B对象
	 * @param {Number} ev.B.height 区域B的高度
	 * @param {Number} ev.B.width 区域B的宽度
	 */

	/**
	 * @class Splitter
	 * @constructor
	 * @param {String} element jQuery dom 选择器
	 */	
	
	var Splitter = function(element) {
			this.element = $(element)
		}

	/**
	 * splitter 计数器
	 * @property splitterCounter
	 * @final
	 */
	var splitterCounter = 0;
	
	Splitter.prototype = {
		/**
		 * Splitter的一个实例
		 * @property constructor
		 * @type {Object}
		 */		
		constructor: Splitter,
		/**
		 * Splitter 创建函数
		 * @method create
		 * @param {Object} options 组件配置
		 * @param {String} options.type 分割方式 v:垂直分割,h:水平分割
		 * @param {String} options.dock 驻停位置 top:顶部,bottom:底部,left:左侧,right:右侧
		 * @param {Number} options.minLeft 左侧最小尺寸
		 * @param {Number} options.minRight 右侧最小尺寸
		 * @param {Number} options.minTop 顶部最小尺寸
		 * @param {Number} options.minBottom 底部最小尺寸
		 * @param {Number} options.maxLeft 左侧最大尺寸
		 * @param {Number} options.maxRight 右侧最大尺寸
		 * @param {Number} options.maxTop 顶部最大尺寸
		 * @param {Number} options.maxBottom 底部最大尺寸
		 * @param {Number} options.sizeLeft 左侧初始尺寸
		 * @param {Number} options.sizeRight 右侧初始尺寸
		 * @param {Number} options.sizeTop 顶部初始尺寸
		 * @param {Number} options.sizeBottom 底部初始尺寸
		 * @param {Boolean} options.anchorToWindow 是否自动锚定到窗口大小 true,false 
		 * @param {Boolean} options.resizeToWidth 自动调整宽度 true,false
		 * @param {Function} options.onresize 参考Events onresize说明
		 * @example
		 * &#x60;&#x60;&#x60;javascript
		 * 	//创建一个缺省配置的垂直分割框架 
		 * 	$(sSign).splitter();
		 * 	//创建一个水平分割框架
		 * 	$(sSign).splitter({type: &#x27;h&#x27;});
		 * &#x60;&#x60;&#x60;
		 */	
		create: function(options) {
			this.options = options || {};

			if ($(this).is(&quot;.splitter&quot;)) return; // already a splitter
			if ($(this.element).attr(&quot;data-splitter-initialized&quot;)) return
			var zombie; // left-behind splitbar for outline resizes
			/**
			 * 用于判断是否触发resize方法
			 * @method resize_auto_fired
			 * @return {Boolean} 判断浏览器版本是否小于ie9
			 * @private
			 */
			function resize_auto_fired() {
				// Returns true when the browser natively fires the resize 
				// event attached to the panes elements
				return ($.browser.msie &amp;&amp; (parseInt($.browser.version) &lt; 9));
			}
			/**
			 * 设置bar状态
			 * @method setBarState
			 * @param {String} state 状态样式Class
			 * @private
			 */
			function setBarState(state) {
				bar.removeClass(opts.barStateClasses).addClass(state);
			}
			/**
			 * 按下鼠标开始拖动时触发(mousedown)
			 * @method startSplitMouse
			 * @param {Event} evt 事件对象
			 * @private
			 */
			function startSplitMouse(evt) {
				if (evt.which != 1) return; // left button only
				bar._startpos = A[0][opts.pxSplit];

				bar.removeClass(opts.barHoverClass);
				if (1||opts.outline) {
					zombie = zombie || bar.clone(false).insertAfter(A);
					bar.removeClass(opts.barDockedClass);
				}
				setBarState(opts.barActiveClass)
				// Safari selects A/B text on a move; iframes capture mouse events so hide them
				panes.css(&quot;-webkit-user-select&quot;, &quot;none&quot;).find(&quot;iframe&quot;).addClass(opts.iframeClass);
				A._posSplit = A[0][opts.pxSplit] - evt[opts.eventPos];
				$(document).bind(&quot;mousemove&quot; + opts.eventNamespace, doSplitMouse).bind(&quot;mouseup&quot; + opts.eventNamespace, evt.data, endSplitMouse);
			}

			/**
			 * 鼠标拖动时触发
			 * @method doSplitMouse
			 * @param {Event} evt 事件对象
			 * @private
			 */
			function doSplitMouse(evt) {
				var pos = A._posSplit + evt[opts.eventPos],
					range = Math.max(0, Math.min(pos, splitter._DA - bar._DA)),
					limit = Math.max(A._min, splitter._DA - B._max, Math.min(pos, A._max, splitter._DA - bar._DA - B._min));

				A.removeClass(opts.noshow); //css(&quot;display&quot;,&quot;&quot;);
				B.removeClass(opts.noshow); //css(&quot;display&quot;,&quot;&quot;);
				if (1||opts.outline) {
					// Let docking splitbar be dragged to the dock position, even if min width applies
					if ((opts.dockPane == A &amp;&amp; pos &lt; Math.max(A._min, bar._DA)) || (opts.dockPane == B &amp;&amp; pos &gt; Math.min(pos, A._max, splitter._DA - bar._DA - B._min))) {
						bar.addClass(opts.barDockedClass).css(opts.origin, range);
					} else {
						bar.removeClass(opts.barDockedClass).css(opts.origin, limit);
					}
					bar._DA = bar[0][opts.pxSplit];
				} else resplit(pos);
				setBarState(pos == limit ? opts.barActiveClass : opts.barLimitClass);
			}
			/**
			 * 鼠标按键抬起时触发(mouseup)
			 * @method endSplitMouse
			 * @param {Event} evt 事件对象
			 * @private
			 */
			function endSplitMouse(evt) {
				setBarState(opts.barNormalClass);
				bar.addClass(opts.barHoverClass);
				var pos = A._posSplit + evt[opts.eventPos];
				if (1||opts.outline) {
					zombie &amp;&amp; zombie.remove();
					zombie = null;
					resplit(pos);
				}
				panes.css(&quot;-webkit-user-select&quot;, &quot;text&quot;).find(&quot;iframe&quot;).removeClass(opts.iframeClass);
				$(document).unbind(&quot;mousemove&quot; + opts.eventNamespace + &quot; mouseup&quot; + opts.eventNamespace);

				var outputObj = {
					A: {
						height: A.height(),
						width: A.width()
					},
					B: {
						height: B.height(),
						width: B.width()
					}
				};
				// 判断开始位置是否和结束位置一致，事件对象是否为函数类型，然后执行
				bar._startpos != A[0][opts.pxSplit] &amp;&amp; evt.data.eventObj &amp;&amp; typeof evt.data.eventObj == &quot;function&quot; &amp;&amp; evt.data.eventObj(outputObj);
			}
			/**
			 * 重新进行尺寸分割
			 * @method resplit
			 * @param {Number} pos      分割点位置
			 * @param {object} eventObj 待触发回调的事件函数对象
			 * @private
			 */
			function resplit(pos, eventObj) {
				bar._DA = bar[0][opts.pxSplit]; // bar size may change during dock
				// Constrain new splitbar position to fit pane size and docking limits
				if ((opts.dockPane == A &amp;&amp; pos &lt; Math.max(A._min, bar._DA)) || (opts.dockPane == B &amp;&amp; pos &gt; Math.min(pos, A._max, splitter._DA - bar._DA - B._min))) {
					bar.addClass(opts.barDockedClass);
					bar._DA = bar[0][opts.pxSplit];
					pos = opts.dockPane == A ? 0 : splitter._DA - bar._DA;
					if (bar._pos == null) bar._pos = A[0][opts.pxSplit];
				} else {
					bar.removeClass(opts.barDockedClass);
					bar._DA = bar[0][opts.pxSplit];
					bar._pos = null;
					pos = Math.max(A._min, splitter._DA - B._max, Math.min(pos, A._max, splitter._DA - bar._DA - B._min));
				}
				// Resize/position the two panes
				bar.css(opts.origin, pos).css(opts.fixed, splitter._DF);
				// get A Border width infomation 获取A Border 的宽度信息 
				var A_BL = A.css(&quot;border-left-width&quot;).replace(&quot;px&quot;, &quot;&quot;),
					A_BR = A.css(&quot;border-right-width&quot;).replace(&quot;px&quot;, &quot;&quot;),
					A_BT = A.css(&quot;border-top-width&quot;).replace(&quot;px&quot;, &quot;&quot;),
					A_BB = A.css(&quot;border-bottom-width&quot;).replace(&quot;px&quot;, &quot;&quot;),

					B_BL = B.css(&quot;border-left-width&quot;).replace(&quot;px&quot;, &quot;&quot;),
					B_BR = B.css(&quot;border-right-width&quot;).replace(&quot;px&quot;, &quot;&quot;),
					B_BT = B.css(&quot;border-top-width&quot;).replace(&quot;px&quot;, &quot;&quot;),
					B_BB = B.css(&quot;border-bottom-width&quot;).replace(&quot;px&quot;, &quot;&quot;);

				if (opts.type == &quot;v&quot;) {
					A.css(opts.origin, 0).css(opts.split, pos &lt; (A_BL + A_BR - 0) ? 0 : pos - A_BL - A_BR).css(opts.fixed, splitter._DF &lt; (A_BT + A_BB - 0) ? 0 : splitter._DF - A_BT - A_BB);

					pos == 0 ? A.addClass(opts.noshow) : &quot;&quot;; //css(&quot;display&quot;,&quot;none&quot;):&#x27;&#x27;;
					B.css(opts.origin, pos + bar._DA).css(opts.split, splitter._DA - bar._DA - pos - B_BL - B_BR).css(opts.fixed, splitter._DF - B_BT - B_BB);

					pos == splitter._DA - bar._DA ? B.addClass(opts.noshow) : &quot;&quot;; //css(&quot;display&quot;,&quot;none&quot;):&#x27;&#x27;;
				} else if (opts.type = &quot;h&quot;) {
					A.css(opts.origin, 0).css(opts.split, pos - A_BT - A_BB).css(opts.fixed, splitter._DF - A_BL - A_BR);
					pos == 0 ? A.addClass(opts.noshow) : &quot;&quot;;
					B.css(opts.origin, pos + bar._DA).css(opts.split, splitter._DA - bar._DA - pos - B_BT - B_BB).css(opts.fixed, splitter._DF - B_BL - B_BR);
					pos == splitter._DA - bar._DA ? B.addClass(opts.noshow) : &quot;&quot;;
				}

				//				A.css(opts.origin, 0).css(opts.split, pos-2).css(opts.fixed, splitter._DF-2);
				//				B.css(opts.origin, pos + bar._DA).css(opts.split, splitter._DA - bar._DA - pos-2).css(opts.fixed, splitter._DF-2);
				var outputObj = {
					A: {
						height: A.height(),
						width: A.width()
					},
					B: {
						height: B.height(),
						width: B.width()
					}
				};
				eventObj &amp;&amp; typeof eventObj == &quot;function&quot; &amp;&amp; eventObj(outputObj);
				// IE fires resize for us; all others pay cash
				if (!resize_auto_fired()) panes.trigger(&quot;resize&quot;);
			}

			function dimSum(jq, dims) {
				// Opera returns -1 for missing min/max width, turn into 0
				var sum = 0;
				for (var i = 1; i &lt; arguments.length; i++)
				sum += Math.max(parseInt(jq.css(arguments[i]), 10) || 0, 0);
				return sum;
			}
			/**
			 * 重算分割尺寸
			 * @method resize
			 * @param {Number} size  分割点所处位置
			 * @private
			 */
			function resize(size) {
				// Determine new width/height of splitter container
				splitter._DF = splitter[0][opts.pxFixed] - splitter._PBF;
				splitter._DA = splitter[0][opts.pxSplit] - splitter._PBA;

				// Bail if splitter isn&#x27;t visible or content isn&#x27;t there yet
				if (splitter._DF &lt;= 0 || splitter._DA &lt;= 0) return;

				// if nothing changed, no need to resize 
				if (splitter._oldW == splitter.width() &amp;&amp; splitter._oldH == splitter.height()) return; // nothing changed
				splitter._oldW = splitter.width();
				splitter._oldH = splitter.height();

				// Re-divvy the adjustable dimension; maintain size of the preferred pane
				resplit(!isNaN(size) ? size : (!(opts.sizeRight || opts.sizeBottom) ? A[0][opts.pxSplit] : splitter._DA - B[0][opts.pxSplit] - bar._DA), opts.onresize);
				setBarState(opts.barNormalClass);
			}

			/**
			 * 获取panel边框尺寸
			 * @method getPanelBorderSize
			 * @param  {String} type  h:横向分割 ,v:纵向分割
			 * @param  {HTMLElement} panel 区域对象
			 * @return {Number} 边框尺寸
			 * @private
			 */
			function getPanelBorderSize(type, panel) {
				var A = $(panel);
				var A_BL = A.css(&quot;border-left-width&quot;).replace(&quot;px&quot;, &quot;&quot;),
					A_BR = A.css(&quot;border-right-width&quot;).replace(&quot;px&quot;, &quot;&quot;),
					A_BT = A.css(&quot;border-top-width&quot;).replace(&quot;px&quot;, &quot;&quot;),
					A_BB = A.css(&quot;border-bottom-width&quot;).replace(&quot;px&quot;, &quot;&quot;);

				var bs = 0;

				if (type == &quot;h&quot;) {
					bs = A_BT * 1 + A_BB * 1;
				} else {
					bs = A_BL * 1 + A_BR * 1;
				}
				return bs;
			}

			// Determine settings based on incoming opts, element classes, and defaults
			var vh = (this.options.splitHorizontal ? &#x27;h&#x27; : this.options.splitVertical ? &#x27;v&#x27; : this.options.type) || &#x27;v&#x27;;
			var opts = $.extend({
				// Defaults here allow easy use with ThemeRoller
				splitterClass: &quot;splitter ui-widget ui-widget-content&quot;,
				paneClass: &quot;splitter-pane&quot;,
				barClass: &quot;splitter-bar&quot;,
				barNormalClass: &quot;ui-state-default&quot;,
				// splitbar normal
				barHoverClass: &quot;ui-state-hover&quot;,
				// splitbar mouse hover
				barActiveClass: &quot;ui-state-highlight&quot;,
				// splitbar being moved
				barLimitClass: &quot;ui-state-error&quot;,
				// splitbar at limit
				iframeClass: &quot;splitter-iframe-hide&quot;,
				// hide iframes during split
				eventNamespace: &quot;.splitter&quot; + (++splitterCounter),
				pxPerKey: 8,
				// splitter px moved per keypress
				tabIndex: 0,
				// tab order indicator
				accessKey: &#x27;&#x27;,
				// accessKey for splitbar,
				noshow: &quot;none&quot;
			}, {
				// user can override
				v: { // Vertical splitters:
					keyLeft: 39,
					keyRight: 37,
					cursor: &quot;e-resize&quot;,
					barStateClass: &quot;splitter-bar-vertical&quot;,
					barDockedClass: &quot;splitter-bar-vertical-docked&quot;
				},
				h: { // Horizontal splitters:
					keyTop: 40,
					keyBottom: 38,
					cursor: &quot;n-resize&quot;,
					barStateClass: &quot;splitter-bar-horizontal&quot;,
					barDockedClass: &quot;splitter-bar-horizontal-docked&quot;
				}
			}[vh], this.options, {
				// user cannot override
				v: { // Vertical splitters:
					type: &#x27;v&#x27;,
					eventPos: &quot;pageX&quot;,
					origin: &quot;left&quot;,
					split: &quot;width&quot;,
					pxSplit: &quot;offsetWidth&quot;,
					pxcSplit: &quot;clientWidth&quot;,
					//处理在ie情况下的判断
					side1: &quot;Left&quot;,
					side2: &quot;Right&quot;,
					fixed: &quot;height&quot;,
					pxFixed: &quot;offsetHeight&quot;,
					side3: &quot;Top&quot;,
					side4: &quot;Bottom&quot;
				},
				h: { // Horizontal splitters:
					type: &#x27;h&#x27;,
					eventPos: &quot;pageY&quot;,
					origin: &quot;top&quot;,
					split: &quot;height&quot;,
					pxSplit: &quot;offsetHeight&quot;,
					pxcSplit: &quot;clientHeight&quot;,
					side1: &quot;Top&quot;,
					side2: &quot;Bottom&quot;,
					fixed: &quot;width&quot;,
					pxFixed: &quot;offsetWidth&quot;,
					side3: &quot;Left&quot;,
					side4: &quot;Right&quot;
				}
			}[vh]);
			opts.barStateClasses = [opts.barNormalClass, opts.barHoverClass, opts.barActiveClass, opts.barLimitClass].join(&#x27; &#x27;);

			// Create jQuery object closures for splitter and both panes
			var splitter = $(this.element).css({
				position: &quot;relative&quot;
			}).addClass(opts.splitterClass).attr(&quot;data-splitter-initialized&quot;, true)

			var panes = $(&quot;&gt;*&quot;, splitter[0]).addClass(opts.paneClass).css({
				position: &quot;absolute&quot;,
				// positioned inside splitter container
				&quot;z-index&quot;: &quot;1&quot;,
				// splitbar is positioned above
				&quot;-moz-outline-style&quot;: &quot;none&quot; // don&#x27;t show dotted outline
			});

			var A = $(panes[0]),
				B = $(panes[1]); // A = left/top, B = right/bottom
			opts.dockPane = opts.dock &amp;&amp; (/right|bottom/.test(opts.dock) ? B : A);

			// Focuser element, provides keyboard support; title is shown by Opera accessKeys
			var focuser = $(&#x27;&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;&#x27;).attr({
				accessKey: opts.accessKey,
				tabIndex: opts.tabIndex,
				title: opts.splitbarClass
			}).bind(($.browser.opera ? &quot;click&quot; : &quot;focus&quot;) + opts.eventNamespace, function() {
				this.focus();
				bar.addClass(opts.barActiveClass)
			}).bind(&quot;keydown&quot; + opts.eventNamespace, function(e) {
				var key = e.which || e.keyCode;
				var dir = key == opts[&quot;key&quot; + opts.side1] ? 1 : key == opts[&quot;key&quot; + opts.side2] ? -1 : 0;
				if (dir) resplit(A[0][opts.pxSplit] + dir * opts.pxPerKey, false);
			}).bind(&quot;blur&quot; + opts.eventNamespace, function() {
				bar.removeClass(opts.barActiveClass)
			});

			// Splitbar element
			var bar = $(&#x27;&lt;div&gt;&lt;/div&gt;&#x27;).insertAfter(A).addClass(opts.barClass).addClass(opts.barStateClass).append(focuser).attr({
				unselectable: &quot;on&quot;
			}).css({
				position: &quot;absolute&quot;,
				&quot;user-select&quot;: &quot;none&quot;,
				&quot;-webkit-user-select&quot;: &quot;none&quot;,
				&quot;-khtml-user-select&quot;: &quot;none&quot;,
				&quot;-moz-user-select&quot;: &quot;none&quot;,
				&quot;z-index&quot;: &quot;100&quot;
			}).bind(&quot;mousedown&quot; + opts.eventNamespace, {
				eventObj: opts.onresize
			}, startSplitMouse).bind(&quot;mouseover&quot; + opts.eventNamespace, function() {
				$(this).addClass(opts.barHoverClass);
			}).bind(&quot;mouseout&quot; + opts.eventNamespace, function() {
				$(this).removeClass(opts.barHoverClass);
			});
			// Use our cursor unless the style specifies a non-default cursor
			if (/^(auto|default|)$/.test(bar.css(&quot;cursor&quot;))) bar.css(&quot;cursor&quot;, opts.cursor);

			// Cache several dimensions for speed, rather than re-querying constantly
			// These are saved on the A/B/bar/splitter jQuery vars, which are themselves cached
			// DA=dimension adjustable direction, PBF=padding/border fixed, PBA=padding/border adjustable
			bar._DA = bar[0][opts.pxSplit];
			splitter._PBF = dimSum(splitter, &quot;border&quot; + opts.side3 + &quot;Width&quot;, &quot;border&quot; + opts.side4 + &quot;Width&quot;);
			splitter._PBA = dimSum(splitter, &quot;border&quot; + opts.side1 + &quot;Width&quot;, &quot;border&quot; + opts.side2 + &quot;Width&quot;);
			A._pane = opts.side1;
			B._pane = opts.side2;
			$.each([A, B], function() {
				this._splitter_style = this.style;
				this._min = opts[&quot;min&quot; + this._pane] || dimSum(this, &quot;min-&quot; + opts.split);
				this._max = opts[&quot;max&quot; + this._pane] || dimSum(this, &quot;max-&quot; + opts.split) || 9999;
				//				this._init = opts[&quot;size&quot; + this._pane] === true ? parseInt($.css(this[0], opts.split), 10) : opts[&quot;size&quot; + this._pane];
				this._init = opts[this._pane] === true ? parseInt($.css(this[0], opts.split), 10) : opts[this._pane];
			});

			// Determine initial position, get from cookie if specified
			var initPos = A._init;
			if (!isNaN(B._init)) // recalc initial B size as an offset from the top or left side
			initPos = splitter[0][opts.pxSplit] - splitter._PBA - B._init - bar._DA;
			if (isNaN(initPos)) // King Solomon&#x27;s algorithm
			initPos = Math.round((splitter[0][opts.pxSplit] - splitter._PBA - bar._DA) / 2);

			// Resize event propagation and splitter sizing
			if (opts.anchorToWindow) opts.resizeTo = window;
			if (opts.resizeTo) {
				splitter._hadjust = dimSum(splitter, &quot;borderTopWidth&quot;, &quot;borderBottomWidth&quot;, &quot;marginBottom&quot;);
				splitter._hmin = Math.max(dimSum(splitter, &quot;minHeight&quot;), 20);
				$(window).bind(&quot;resize&quot; + opts.eventNamespace, function() {
					var top = splitter.offset().top;
					var eh = $(opts.resizeTo).height();
					splitter.css(&quot;height&quot;, Math.max(eh - top - splitter._hadjust, splitter._hmin) + &quot;px&quot;);
					if (!resize_auto_fired()) resize(); //splitter.triggerHandler(&quot;resize&quot;);
				}).triggerHandler(&quot;resize&quot; + opts.eventNamespace);
			} else if (opts.resizeToWidth &amp;&amp; !resize_auto_fired()) {
				$(window).bind(&quot;resize&quot; + opts.eventNamespace, function() {
					resize();
				});
			}

			// Docking support
			if (opts.dock) {
				splitter.bind(&quot;toggleDock&quot; + opts.eventNamespace, function() {
					// 获取去除border后的panel尺寸
					//					var pw = opts.dockPane[0][opts.pxSplit] - getPanelBorderSize(opts.type, opts.dockPane[0]);
					//					splitter.triggerHandler(pw ? &quot;dock&quot; : &quot;undock&quot;);
					if (opts.dockPane.first().hasClass(opts.noshow)) {
						opts.dockPane.first().removeClass(opts.noshow); //css(&quot;display&quot;,&quot;&quot;);
						splitter.triggerHandler(&quot;undock&quot;);
					} else {
						splitter.triggerHandler(&quot;dock&quot;);
						A.removeClass(opts.noshow);
						B.removeClass(opts.noshow);
					}

				}).bind(&quot;dock&quot; + opts.eventNamespace, function(evt) {
					//var pw = A[0][opts.pxSplit];
					var pw = A[0][opts.pxSplit] - getPanelBorderSize(opts.type, A[0]);

					if (!pw) return;
					//保存原有位置,以便undock时恢复
					bar._oldpos = A[0][opts.pxSplit];
					var x = {};
					x[opts.origin] = opts.dockPane == A ? 0 : splitter[0][opts.pxSplit] - splitter._PBA - bar[0][opts.pxSplit];
					bar.animate(x, opts.dockSpeed || 1, opts.dockEasing, function() {
						bar.addClass(opts.barDockedClass);
						resplit(x[opts.origin], opts.onresize);
					});

				}).bind(&quot;undock&quot; + opts.eventNamespace, function(evt) {
					var pw = A[0][opts.pxcSplit] &gt; 0 &amp;&amp; splitter._DA - bar._DA &gt; A[0][opts.pxSplit];

					if (pw) return;
					var x = {};
					x[opts.origin] = bar._oldpos + &quot;px&quot;;
					bar.removeClass(opts.barDockedClass).animate(x, opts.undockSpeed || opts.dockSpeed || 1, opts.undockEasing || opts.dockEasing, function() {
						resplit(bar._oldpos, opts.onresize);
						bar._oldpos = null;
					});
				});

				if (opts.dockKey) $(&#x27;&lt;a title=&quot;&#x27; + opts.splitbarClass + &#x27; toggle dock&quot; href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;&#x27;).attr({
					accessKey: opts.dockKey,
					tabIndex: -1
				}).appendTo(bar).bind($.browser.opera ? &quot;click&quot; : &quot;focus&quot;, function() {
					splitter.triggerHandler(&quot;toggleDock&quot;);
					this.blur();
				});
				bar.bind(&quot;dblclick&quot;, function() {
					splitter.triggerHandler(&quot;toggleDock&quot;);
				})
			}

			// Resize event handler; triggered immediately to set initial position
			splitter.bind(&quot;destroy&quot; + opts.eventNamespace, function() {
				$([window, document]).unbind(opts.eventNamespace);
				bar.unbind().remove();
				panes.removeClass(opts.paneClass);
				splitter.removeClass(opts.splitterClass).add(panes).unbind(opts.eventNamespace).attr(&quot;style&quot;, function(el) {
					return this._splitter_style || &quot;&quot;; //TODO: save style
				});
				splitter = bar = focuser = panes = A = B = opts = options = null;
			}).bind(&quot;resize&quot; + opts.eventNamespace, function(e, size) {
				resize(size);
			}).trigger(&quot;resize&quot;, [initPos]);
		}
	}

	/* TAB PLUGIN DEFINITION
	 * ===================== */

	var old = $.fn.splitter

	$.fn.splitter = function(option, param) {
			return this.each(function() {
				var $this = $(this),
					data = $this.data(&#x27;splitter&#x27;)
					if (!data) $this.data(&#x27;splitter&#x27;, (data = new Splitter(this)))
					if (typeof option == &#x27;string&#x27;) data[option](param)
			})
		}

	$.fn.splitter.Constructor = Splitter

	/* SPLITTER NO CONFLICT
	 * =============== */

	$.fn.splitter.noConflict = function() {
		$.fn.splitter = old
		return this
	}

	/* SPLITTER DATA-API
	 * ============ */
	/**
	 * data-api 接口 
	 * @event click.splitter.data-api
	 * @param {[type]} e 事件对象
	 */
	$(document).on(&#x27;click.splitter.data-api&#x27;, &#x27;[data-toggle=&quot;splitter&quot;]&#x27;, function(e) {

		var $this = $(this),
			href = $this.attr(&#x27;href&#x27;),
			$targetList = $($this.attr(&#x27;data-target&#x27;) || (href &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, &#x27;&#x27;))),
			option, $target, iCount = $targetList.length; //strip for ie7
		e.preventDefault();

		if (iCount &gt; 0) {
			//处理第一个
			$target = $($targetList[0])
			option = $target.data(&#x27;splitter&#x27;) ? &#x27;create&#x27; : $.extend($target.data(), $this.data())
			$target.splitter(&#x27;create&#x27;, option);
			//处理多重分割
			for (var i = 1; i &lt; iCount; i++) {
				$target = $($targetList[i])
				option = $target.data(&#x27;splitter&#x27;) ? &#x27;create&#x27; : $.extend($target.data(), $this.data())

				$target.css({
					&quot;overflow&quot;: &quot;hidden&quot;
				}).splitter(&#x27;create&#x27;, option);
			}
		}
	});

})(window.jQuery);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
